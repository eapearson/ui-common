define(['nunjucks', 'jquery', 'q', 'postal', 'kb.session', 'kb.utils', 'kb.logger', 'json!functional-site/config.json'],
    function (nunjucks, $, Q, Postal, Session, Utils, Logger, config) {
        "use strict";
        var BaseWidget = Object.create({}, {
            // The init function interfaces this object with the caller, and sets up any 
            // constants and constant state.
            /**
             * Initialize the base widget, providing the instance part of the "base".
             * Note that this uses the "non-super" method of super-ing, using the 
             * "name" of the widget object as a prefix for init.
             * 
             * @function BaseWidget_init
             * @public
             * 
             * @params {object} cfg - a configuration object
             * @property {string|HTMLElement} container - the DOM node where this widget will be rendered
             * @property {string} name - the name of this widget; used for constructing home directory
             * and other naming contexts.
             * @property {string} title - a human-meaningful short description of the widget
             */
            BaseWidget_init: {
                value: function (cfg) {
                    this.generatedId = 0;

                    // First we get the global config.

                    // The global config is derived from the module definition, which gets it from the 
                    // functional site main config file directly. The setup property of the config defines
                    // the current set of settings (production, development, etc.)
                    this.globalConfig = config[config.setup];

                    // TODO: implement local config and config merging.
                    this.localConfig = {};
                    this.initConfig = cfg || {};
                    this.setupConfig();

                    // PARAMS          
                    // The params object is used to hold any parameterized input.
                    // Note that params may change. Parameters are information the object
                    // has about its runtime limitations. When a parameter changes, the
                    // widget may need to re-fetch or calculate state and/or re-render.
                    this.params = {};

                    // AUTH
                    // Auth state can change at any time -- the syncAuth method knows how to 
                    // rebuild the widget after auth state change.
                    this.setupAuth();

                    // Set up widget based on the config, params, and auth.
                    this.setupCoreApp();

                    // The child widget may implement this.
                    this.setup();
                    
                    this.setupTemplates();

                    // MESSAGES
                    // The widget supports arbitrary messages provided by the widget code to the
                    // interface. A simple list.
                    this.messages = [];

                    // ERROR
                    this.error = null;

                    // The state object is used to hold any data generated by this 
                    // widget.
                    // It is merged onto the context object prior to rendering.
                    // state is either: none, initialized, changed, 
                    this.setupState();

                    // HEARTBEAT
                    this.setupHeartbeat();

                    // STATUS

                    // Now use a status flag ...
                    /*
                     new - newly created
                     ready - ready for rendering and looping into the heartbeat 
                     dirty - state changed, need refresh
                     clean - view reflects state, no need to re-render
                     error - error state, don't fetch or refresh without user intervention (?)
                     stopped - stop call has been made in preparation for destroying
                     */
                    this.status = 'new';

                    return this;
                }
            },
            setupConfig: {
                value: function () {
                    this.configs = [{}, this.initConfig, this.localConfig, this.globalConfig];

                    // Check for required and apply defaults.
                    if (!this.hasConfig('container')) {
                        throw 'A container is required by this Widget, but was not provided.';
                    }

                    if (!this.hasConfig('name')) {
                        throw 'Widget name is required';
                    }

                    if (!this.hasConfig('title')) {
                        throw 'Widget title is required';
                    }
                }
            },
            setupCoreApp: {
                value: function () {
                    // Should be run after configuration changes.
                    // May touch parts of the widget object, so care should be taken
                    // to syncronize or just plain rebuild.

                    this.container = this.getConfig('container');
                    if (typeof this.container === 'string') {
                        this.container = $(this.container);
                    }

                    // OTHER CONFIG
                    // The widget requires a name to use for various purposes.
                    this.widgetCollection = this.getConfig('collection');
                    this.widgetName = this.getConfig('name');
                    this.widgetTitle = this.getConfig('title');

                    // Each widget gets an instance id -- which can be used
                    // for example to provide unique identifiers for this 
                    // widget.
                    this.instanceId = this.genId();

                    this.logger = Object.create(Logger).init({
                        source: this.widgetName
                    });

                    return;
                }
            },
            setupAuth: {
                value: function () {
                    Session.refreshSession();
                }
            },
            setupTemplates: {
                value: function () {
                     // Set up the templating system.
                    // NB the templating requires a dedicated widget resources directory in 
                    //   /src/widgets/WIDGETNAME/templates
                    this.templates = {};
                    this.templates.env = new nunjucks.Environment(new nunjucks.WebLoader(this.getWidgetPath() + '/templates'), {
                        'autoescape': false
                    });
                    this.templates.env.addFilter('kbmarkup', function (s) {
                        if (s) {
                            s = s.replace(/\n/g, '<br>');
                        }
                        return s;
                    });
                    
                    // This is the cache of templates.
                    this.templates.cache = {};

                    // The context object is what is given to templates.
                    this.context = {};
                    this.context.env = {
                        widgetTitle: this.widgetTitle,
                        widgetName: this.widgetName
                    };
                    
                    // NB this means that when clearing state or params, the object
                    // should not be blown away.
                    this.context.state = this.state;
                    this.context.params = this.params;
                }
            },
            setupState: {
                value: function () {
                    this.state = {};
                    this.stateMeta = {
                        status: 'none',
                        timestamp: new Date()
                    };
                }
            },
            setupHeartbeat: {
                value: function () {
                    // refreshBeat is a one minute (or whatever) approximate timer for 
                    // refreshing more expensive data.
                    // this.refreshBeat = 0;
                    //
                    this.refreshInterval = 10000;
                    this.refreshLastTime = null;
                }
            },
            
            // LIFECYCLE

            go: {
                value: function () {
                    this.start().done();
                }
            },
            start: {
                value: function () {
                    // This creates the initial UI -- loads the css, inserts layout html.
                    // For simple widgets this is all the setup needed.
                    // For more complex one, parts of the UI may be swapped out.
                    return Q.Promise(function (resolve, reject) {
                        this.renderUI();
                        this.renderWaitingView();
                        this.setInitialState()
                            .then(function () {
                                this.status = 'dirty';
                                // this.setupUI();
                                this.startSubscriptions();
                                if (this.afterStart) {
                                    this.afterStart();
                                }
                                resolve(this);
                            }.bind(this))
                            .catch(function (err) {
                                this.setError(err);
                            }.bind(this))
                            .finally(function () {
                                // nothing for now.
                            }.bind(this))
                            .done();
                    }.bind(this));
                }
            },
            setup: {
                value: function () {
                    // does whatever the widget needs to do to set itself up
                    // after config, params, and auth have been configured.
                    return this;
                }
            },
            renderUI: {
                value: function () {
                    this.loadCSS();
                    this.renderLayout();
                    return this;
                }
            },
            startSubscriptions: {
                value: function () {
                    // Set up listeners for any kbase events we are interested in:
                    this.subscriptions = [];

                    this.subscriptions.push(Postal.channel('app').subscribe('heartbeat', function (data) {
                        this.handleHeartbeat(data);
                    }.bind(this)));
                }
            },
            stopSubscriptions: {
                value: function () {
                    if (this.subscriptions) {
                        this.subscriptions.forEach(function (sub) {
                            sub.unsubscribe();
                        });
                    }
                }
            },
            stop: {
                value: function () {
                    if (this.heartbeatSubscription) {
                        this.heartbeatSubscription.unsubscribe();
                    }
                    if (this.onStop) {
                        this.onStop();
                    }
                }
            },
            destroy: {
                value: function () {
                    // tear down any events, etc. that are not attached
                    // to the local container.
                }
            },
            // CONFIG
            getConfig: {
                value: function (key, defaultValue) {
                    var i;
                    for (i = 0; i < this.configs.length; i++) {
                        if (Utils.getProp(this.configs[i], key) !== undefined) {
                            return Utils.getProp(this.configs[i], key);
                        }
                    }
                    return defaultValue;
                }
            },
            setConfig: {
                value: function (key, value) {
                    // sets it on the first config, which is the override config.
                    Utils.setProp(this.configs[0], key, value);
                }
            },
            hasConfig: {
                value: function (key) {
                    for (var i = 0; i < this.configs.length; i++) {
                        if (Utils.getProp(this.configs[i], key) !== undefined) {
                            return true;
                        }
                    }
                    return false;
                }
            },
            // PARAMETERS
            // Parameters are typically passed into the init() method, and represent external values that vary for each 
            // new object. Typical use cases are url query variables.
            setParam: {
                value: function (path, value) {
                    Utils.setProp(this.params, path, value);
                    this.refresh().done();
                }
            },
            recalcState: {
                value: function () {
                    this.setInitialState()
                            .then(function () {
                                return this.refresh();
                            }.bind(this))
                            .catch(function (err) {
                                this.setError(err);
                            }.bind(this))
                            .done();
                }
            },
            refresh: {
                value: function () {
                    return Q.Promise(function (resolve) {
                        this.render();
                        resolve();
                    }.bind(this));
                }
            },
            // STATE CHANGES

            /*
             getCurrentState
             This should do prepare the internal state to the point at
             which rendering can occur. It will typically fetch all data and stache it, 
             and perhaps perform some rudimentary analysis.
             */
            setState: {
                value: function (path, value, norefresh) {
                    if (!Utils.isEqual(Utils.getProp(this.state, path), value)) {
                        Utils.setProp(this.state, path, value);
                        // this.onStateChange();
                        this.status = 'dirty';
                    } else {
                        //console.log('no difference ... not saving ' + path); 
                    }
                }
            },
            getState: {
                value: function (path, defaultValue) {
                    return Utils.getProp(this.state, path, defaultValue);                    
                }
            },
            deleteState: {
                value: function (path) {
                    if (path) {
                        Utils.deleteProp(this.state, path);
                    } else {
                        this.state = {};
                    }
                    this.status = 'dirty';
                }
            },            
            doState: {
                value: function (path, fun, defaultValue) {
                    if (Utils.hasProp(this.state, path)) {
                        return fun(Utils.getProp(this.state, path));
                    } else {
                        return defaultValue;
                    }
                }
            },
            setError: {
                value: function (errorValue) {
                    if (!errorValue) {
                        return;
                    }
                    var errorText;
                    if (typeof errorValue === 'string') {
                        errorText = errorValue;
                    } else if (typeof errorValue === 'object') {
                        if (errorValue.message) {
                            errorText = errorValue.message;
                        } else {
                            errorText = '' + error;
                        }
                    }
                    this.error = {
                        message: errorText,
                        original: errorValue
                    };
                    this.refresh().done();
                }
            },
            checkState: {
                value: function (status) {
                    if (this.stateMeta.status === status) {
                        return true;
                    } else {
                        return false;
                    }
                }
            },
            setInitialState: {
                value: function (options) {
                    // The base method just resolves immediately (well, on the next turn.) 
                    return Q.Promise(function (resolve, reject, notify) {
                        resolve();
                    });
                }
            },
            // EVENT HANDLERS

            onLoggedIn: {
                value: function (e, auth) {
                    this.setupAuth();
                    this.setup();
                    this.setInitialState({force: true})
                            .then(function () {
                                this.refresh();
                            }.bind(this));
                }
            },
            onLoggedOut: {
                value: function (e, auth) {
                    this.setupAuth();
                    this.setup();
                    this.setInitialState({force: true}).then(function () {
                        this.refresh();
                    }.bind(this));
                }
            },
            // STATE CALCULATIONS

            // TEMPLATES

            getTemplate: {
                value: function (name) {
                    if (this.templates.cache[name] === undefined) {
                        this.templates.cache[name] = this.templates.env.getTemplate(name + '.html');
                    }
                    return this.templates.cache[name];
                }
            },
            createTemplateContext: {
                value: function (additionalContext) {

                    // The context object is what is given to templates.
                    this.context = {};
                    this.context.env = {
                        widgetTitle: this.widgetTitle,
                        widgetName: this.widgetName
                    };
                    
                    // NB this means that when clearing state or params, the object
                    // should not be blown away.
                    this.context.state = this.state;
                    this.context.params = this.params;

                    // We need to ensure that the context reflects the current auth state.
                    this.context.env.loggedIn = Session.isLoggedIn();
                    if (Session.isLoggedIn()) {
                        this.context.env.loggedInUser = Session.getUsername();
                        this.context.env.username = Session.getUsername();
                        this.context.env.realname = Session.getRealname();
                    } else {
                        delete this.context.env.loggedInUser;
                        delete this.context.env.username;
                        delete this.context.env.realname;
                    }

                    this.context.env.instanceId = this.instanceId;

                    if (additionalContext) {
                        var temp = Utils.merge({}, this.context);
                        return Utils.merge(temp, additionalContext);
                    } else {
                        return this.context;
                    }
                }
            },
            renderTemplate: {
                value: function (name, context) {
                    var template = this.getTemplate(name);
                    if (!template) {
                        throw new Error('Template ' + name + ' not found');
                    }
                    var context = context ? context : this.createTemplateContext();
                    return template.render(context);
                }
            },
            // Generates a unique id for usage on synthesized dom elements.
            genId: {
                value: function () {
                    return 'gen_' + this.widgetName + '_' + this.instanceId + '_' + this.generatedId++;
                }
            },
            renderError: {
                value: function () {
                    var context = this.createTemplateContext({
                        error: {
                            message: Utils.getProp(this.error, 'message')
                        }
                    });
                    this.places.content.html(this.getTemplate('error').render(context));
                }
            },
            renderErrorView: {
                value: function (error) {
                    // Very simple error view.

                    if (error) {
                        var errorText;
                        if (typeof error === 'string') {
                            errorText = error;
                        } else if (typeof error === 'object') {
                            
                            if (error instanceof Error) {
                                errorText = error.message;
                            } else {
                                error = '' + error;
                            }
                        }
                    }

                    var context = this.createTemplateContext({
                        error: errorText
                    });
                    this.places.content.html(this.getTemplate('error').render(context));
                }
            },
            // DOM UPDATE

            // An example universal renderer, which inspects the state of the widget and
            // displays the appropriate content.
            render: {
                value: function () {
                    // Generate initial view based on the current state of this widget.
                    // Head off at the pass -- if not logged in, can't show profile.
                    if (this.error) {
                        this.renderError();
                    } else if (Session.isLoggedIn()) {
                        if (this.places.title) {
                            this.places.title.html(this.widgetTitle);
                        }
                        var content = this.renderTemplate('authorized');
                        this.places.content.html(content);
                    } else {
                        // no profile, no basic aaccount info
                        if (this.places.title) {
                            this.places.title.html(this.widgetTitle);
                        }
                        this.places.content.html(this.renderTemplate('unauthorized'));
                    }
                    return this;
                }
            },
            // These are some very basic renderers for common functions. 

            // This can provide an initial layout, such as a panel, and provide container nodes,
            // such as title and content.
            renderLayout: {
                value: function () {
                    var layout = this.getTemplate('layout').render(this.createTemplateContext());
                    this.container.html(layout);
                    this.places = {
                        title: this.container.find('[data-placeholder="title"]'),
                        alert: this.container.find('[data-placeholder="alert"]'),
                        content: this.container.find('[data-placeholder="content"]')
                    };
                }
            },
            // Render a waiting icon while.
            // This is typically done before getCurrentState which might be doing a time consuming ajax call
            // to fetch data.
            // NB depends on assets.
            renderWaitingView: {
                value: function () {
                    this.places.content.html('<span class="fa fa-spin fa-spinner></span>');
                }
            },
            getWidgetPath: {
                value: function () {
                    var path = '/src/widgets';
                    if (this.widgetCollection) {
                        path += '/' + this.widgetCollection;
                    }
                    path += '/' + this.widgetName;
                    return path; 
                }
            },
            loadCSS: {
                value: function () {
                    $('<link>')
                        .appendTo('head')
                        .attr({type: 'text/css', rel: 'stylesheet'})
                        .attr('href', this.getWidgetPath() + '/style.css');
                }
            },
            renderMessages: {
                value: function () {
                    if (this.places.alert) {
                        this.places.alert.empty();
                        for (var i = 0; i < this.messages.length; i++) {
                            var message = this.messages[i];
                            var alertClass = 'default';
                            switch (message.type) {
                                case 'success':
                                    alertClass = 'success';
                                    break;
                                case 'info':
                                    alertClass = 'info';
                                    break;
                                case 'warning':
                                    alertClass = 'warning';
                                    break;
                                case 'danger':
                                case 'error':
                                    alertClass = 'danger';
                                    break;
                            }
                            var alert = '';
                            alert += '<div class="alert alert-dismissible alert-' + alertClass + '" role="alert">';
                            alert += '<button type="button" class="close" data-dismiss="alert">';
                            alert += '<span aria-hidden="true">&times;</span>';
                            alert += '<span class="sr-only">Close</span>';
                            alert += '</button>';
                            alert += '<strong>' + message.title + '</strong> ' + message.message + '</div>';
                            this.places.alert.append(alert);
                        }
                    }
                }
            },
            clearMessages: {
                value: function () {
                    this.messages = [];
                    this.renderMessages();
                }
            },
            addSuccessMessage: {
                value: function (title, message) {
                    if (message === undefined) {
                        message = title;
                        title = '';
                    }
                    this.messages.push({
                        type: 'success',
                        title: title,
                        message: message
                    });
                    this.renderMessages();
                }
            },
            addWarningMessage: {
                value: function (title, message) {
                    if (message === undefined) {
                        message = title;
                        title = '';
                    }
                    this.messages.push({
                        type: 'warning',
                        title: title,
                        message: message
                    });
                    this.renderMessages();
                }
            },
            addErrorMessage: {
                value: function (title, message) {
                    if (message === undefined) {
                        message = title;
                        title = '';
                    }
                    this.messages.push({
                        type: 'error',
                        title: title,
                        message: message
                    });
                    this.renderMessages();
                }
            },
            logInfo: {
                value: function (message, options) {
                    Logger.logInfo({source: this.widgetName, message: message});
                    if (options && options.raw) {
                        console.log(options.raw);
                    }
                }
            },
            logDeprecation: {
                value: function (message) {
                     Logger.logDeprecation({source: this.widgetName, message: message});
                }
            },
            logWarning: {
                value: function (message) {
                     Logger.logWarning({source: this.widgetName, message: message});
                }
            },
            logError: {
                value: function (message, error) {
                     Logger.logError({source: this.widgetName, message: message,error: error});
                }
            },
            
            handleHeartbeat: {
                value: function (data) {
                    var now = (new Date()).getTime();
                    if (!this.refreshLastTime) {
                        this.refreshLastTime = now;
                    }
                    if (now - this.refreshLastTime >= this.refreshInterval) {
                        if (this.onRefreshbeat) {
                            this.onRefreshbeat(data);
                            this.refreshLastTime = now;
                        }
                    }
                    if (this.onHeartbeat) {
                        this.onHeartbeat(data);
                    }
                }
            },
            onHeartbeat: {
                value: function (data) {
                    if (this.status === 'dirty') {
                        this.refresh()
                            .then(function () {
                                this.status = 'clean';
                            }.bind(this))
                            .catch(function (err) {
                                this.setError(err);
                            }.bind(this))
                            .done();
                    } else if (this.status === 'error') {
                        this.refresh()
                            .then(function () {
                                this.status = 'errorshown';
                            }.bind(this))
                            .catch(function (err) {
                                this.setError(err);
                            }.bind(this))
                            .done();
                    }
                }
            },
            onRefreshbeat: {
                value: function () {
                    this.refreshState()
                        .catch(function (err) {
                            this.setError(err);
                        }.bind(this))
                        .done();
                    return this;
                }
            },
            refreshState: {
                value: function () {
                    return Q.Promise(function (resolve) {
                       resolve(); 
                    });
                }
            },
            findPlaceholder: {
                value: function (placeholder) {
                    return this.container.find('[data-placeholder="' + placeholder + '"]');
                }
            }

        });

        return BaseWidget;
    });
